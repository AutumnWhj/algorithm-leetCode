## 广度优先搜索思想——队列

广度优先搜索每次**以“广度”为第一要务、雨露均沾，一层一层地扫描**，最后也能够将所有的坐标扫描完全：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17190e64f8853081~tplv-t2oaga2asx-watermark.awebp)

按照 BFS 的遍历规则，具体的访问步骤会变成下面这样:

1. 站在入口`A`处（第一层），发现直接能抵达的坐标只有`B`，于是接下来需要访问的就是 `B`。
2. 入口`A`访问完毕，走到 `B` 处（第二层），发现直接能抵达的坐标变成了`C`、`D`和`E`，于是把这三个坐标记为下一层的访问对象。
3. `B`访问完毕，访问第三层。这里我按照从上到下的顺序（你也可以按照其它顺序），先访问 `C`和`D`，然后访问`E`。站在`C`处和`D`处都没有见到新的可以直接抵达的坐标，所以不做额外的动作。但是在`E`处见到了可以直接抵达的`F`和`G`，因此把`F`和`G`记为下一层（第四层）需要访问的对象。
4. 第三层访问完毕，访问第四层。第四层按照从上到下的顺序，先访问的是 `F`。从`F`出发没有可以直接触达的坐标，因此不做额外的操作。接着访问`G`，发现从`G`出发可以直接抵达`H`和`I`，因此把`H`和`I`记为下一层（第五层）需要访问的对象。
5. 第四层访问完毕，访问第五层。第五层按照从上到下的顺序，先访问的是`H`，发现从`H`出发没有可以直接抵达的坐标，因此不作额外的操作。接着访问`I`，发现`I`就是出口，问题得解。

当然啦，这个问题若采用 BFS 的思路来解，那么它其实已经不能说是一个严格的迷宫游戏了——在一个真正的迷宫游戏里，大概率并不会允许我们如此顺利地逐个访问身在同一层次的所有坐标（比如`C`和`D`之间可能就会隔了厚厚的一堵墙，导致你无法在访问`C`后直接去访问`D`）。这里我们基于迷宫游戏，抽象出来的其实是一个更为简单的模型。大家不必拘泥于游戏本身，而应该着重理解这个分层遍历的过程。

在分层遍历的过程中，大家会发现两个规律：

1. 每访问完毕一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉。
2. 站在某个确定坐标的位置上，我们所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们。

丢弃已访问的坐标、记录新观察到的坐标，这个顺序毫无疑问符合了“先进先出”的原则，因此整个 BFS 算法的实现过程，**和队列有着密不可分的关系**。
下面我用一个队列 `queue` 来模拟一下上面的过程：

1. 初始化，先将入口`A`入队（`queue`里现在只有`A`）。
2. 访问入口`A`（第一层），访问完毕后将`A`出队。发现直接能抵达的坐标只有`B`，于是将`B`入队（`queue`里现在只有`B`）。
3. 访问`B`（第二层），访问完毕后将`B`出队。发现直接能抵达的坐标变成了`C`、`D`和`E`，于是把这三个坐标记为下一层的访问对象，也就是把它们全部入队（`queue`里现在是`C`、`D`、`E`）
4. 访问第三层。这里我按照从上到下的顺序（你也可以按照其它顺序），先访问 `C`（访问完毕后`C`出队）和`D`（访问完毕后`D`出队），然后访问`E`（访问完毕后`E`出队）。访问`C`处和`D`处都没有见到新的可以直接抵达的坐标，所以不做额外的动作。但是在`E`处我们见到了可以直接抵达的`F`和`G`，因此把`F`和`G`记为下一层（第四层）需要访问的对象，`F`、`G`依次入队（`queue`里现在是 `F`、`G`）。
5. 访问第五层。第五层按照从上到下的顺序，先访问的是`H`（访问完毕后`H`出队），发现从`H`出发没有可以直接抵达的坐标，因此不作额外的操作。接着访问`I`（访问完毕后`I`出队），发现`I`就是出口，问题得解（此时 `queue` 队列已经被清空）。

在这个过程里，我们其实循环往复地做了以下事情：
依次访问队列里已经有的坐标，将其出队；记录从当前坐标出发可直接抵达的所有坐标，将其入队。

以上逻辑用伪代码表述如下：

```js
function BFS(入口坐标) {
    const queue = [] // 初始化队列queue
    // 入口坐标首先入队
    queue.push(入口坐标)
    // 队列不为空，说明没有遍历完全
    while(queue.length) {
        const top = queue[0] // 取出队头元素  
        
        访问 top // 此处是一些和 top 相关的逻辑，比如记录它对应的信息、检查它的属性等等
        
        // 注意这里也可以不用 for 循环，视题意而定
        for(检查 top 元素出发能够遍历到的所有元素)  {
            queue.push(top能够直接抵达的元素)
        }
        
        queue.shift() // 访问完毕。将队头元素出队
    }
}
```

注意，理论上来说只要我们拿到了 `top`，那么就不再关心队头元素了。因此这个 `shift` 出队的过程，其实是比较灵活的。一般只要我们拿到了 `top`，就可以执行 `shift`了。一些同学习惯于把`top`元素的访问和出队放在一起来做：

```js
const top = queue.shift()
```

## BFS实战：二叉树的层序遍历

```javascript
function BFS(root) {
    const queue = [] // 初始化队列queue
    // 根结点首先入队
    queue.push(root)
    // 队列不为空，说明没有遍历完全
    while(queue.length) {
        const top = queue[0] // 取出队头元素  
        // 访问 top
        console.log(top.val)
        // 如果左子树存在，左子树入队
        if(top.left) {
            queue.push(top.left)
        }
        // 如果右子树存在，右子树入队
        if(top.right) {
            queue.push(top.right)
        }
        queue.shift() // 访问完毕，队头元素出队
    }
}
```

